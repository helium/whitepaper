\documentclass[10pt, nonatbib, nocopyrightspace, reprint]{sigplanconf}

\usepackage[backref=section, linkbordercolor={1 1 1}, urlbordercolor={1 1 1}, citebordercolor={1 1 1}]{hyperref}
\usepackage[ruled, vlined]{algorithm2e}
\usepackage{placeins}
\usepackage{color}
\usepackage{cite}
\usepackage{float}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{bytefield}
\usepackage{booktabs}
\usepackage{float}
\usepackage{tabularx}
\usepackage{pgfplots}
\usepackage{amsmath}
\usepackage{titlesec}

\graphicspath{ {images/} }

\newcommand{\todo}[1]{}
\renewcommand{\todo}[1]{{\color{red} TODO:\ {#1}}}
\pgfplotsset{compat=1.14}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{Helium}
\subtitle{A Decentralized Machine Network}
\authorinfo{Amir Haleem\and Andrew Allen \and Andrew Thompson \and Marc Nijdam \and Rahul Garg}{Helium Systems, Inc.}{August 4, 1997}

\maketitle

\begin{abstract}
The Internet of Things is a \textdollar1.6 trillion industry, with over 8.4 billion connected devices online, and predicted to more than double over the next 2 years. All of these devices need to connect to the internet to function. However, current solutions such as cellular, WiFi, and Bluetooth are suboptimal: they are too expensive, too power hungry, or too limited in range.

Helium is a \emph{decentralized machine network} that enables devices anywhere in the world to wirelessly connect to the internet and geolocate themselves without the need for power-hungry satellite location hardware or expensive cellular plans. Powering the network is a blockchain with a native protocol token incentivizing a two-sided marketplace between coverage providers and coverage consumers. With the introduction of a blockchain, Helium injects decentralization into an industry currently controlled by monopolistic companies. The result is that wireless network coverage becomes a utility, fueled by competition, available anywhere in the world, at a fraction of current costs.

Helium's secure and open-source primitives enable developers to build low-power, internet-connected devices quickly and cost-effectively. Helium has a wide variety of applications across industries and is the first decentralized machine network of its kind.
\end{abstract}

%\newpage

%\tableofcontents
%\newpage

\section{Introduction}

The world is becoming decentralized. A multitude of platforms, technologies, and services are moving from centralized proprietary systems to decentralized open ones. Peer-to-peer networks such as Napster (created by Helium founder Shawn Fanning) \cite{napster} and BitTorrent paved the way for blockchain networks and crypto-currencies to be built. Now Bitcoin, Ethereum, and other blockchain networks have proven the utility of decentralized transaction ledgers. Existing internet services such as file storage, identity verification, and the domain name system are being replaced by modern algorithmic versions. While software-level decentralization has moved quickly, physical networks are taking longer to affect. These networks are more complicated to decentralize as often specialized and expensive hardware is required in order for these systems to function.

Helium is a wide-area wireless networking system, a blockchain and a protocol token. The blockchain runs on a new kind of proof, called \emph{Proof-of-Coverage}, where blocks are created by miners who are providing wireless network coverage in a cryptographically verified physical location and time. The Helium protocol provides a bi-directional data transfer system between wireless devices and the Internet via a network of independent providers that does not rely on a single coordinator, where: (1) devices pay to send \& receive data to the internet and geolocate themselves, (2) miners earn tokens for providing network coverage, and (3) miners earn fees from transactions, and for validating the integrity of the network.

\subsection{Philosophy}

Helium exists due to a set of core beliefs that have driven every component and the underlying purpose of the network and protocol. In this section we outline the requirements that are necessary for building a truly decentralized machine network.

\textbf{Decentralization}. Wireless machine networking is poised to change the way we interact with the physical world and at a scale that is unprecedented, with projections of over \$11.1 trillion in economic value added in under 10 years\cite{mckinsey}. It is critical that this industry be driven forward in a truly decentralized way that allows participation from anyone, anywhere, with no arbitrary gatekeepers. There are many existing products, services and companies participating in the wireless ecosystem today, but nearly all are centralized or proprietary in some form. Some require specialized hardware available from a single vendor, some use proprietary technology, and others tightly control access to infrastructure. Helium exists to make it possible for individuals, businesses, and communities to participate and enable solutions without the need to rely on or trust any external entities.

\textbf{Low Power}. Helium is focused on a specific subset of machine to machine networking---low power devices. While this can cover a very broad range of devices and use cases, we believe that high-power data-intensive applications are well serviced by existing network technologies such as WiFi and LTE\@. Low power wireless networking solutions are in their relative infancy, particularly those which require long range from an access point. A new class of low power wireless solutions---known as \emph{Low Power Wide Area Networks (LPWANs)}---have begun to emerge in the last several years, but are all proprietary in nature or extremely centralized in some capacity. Helium is built upon an entirely new open-source wireless networking protocol designed for machines.

\textbf{Security}. Small, resource constrained devices present an entirely new class of security challenge. Devices can be small, portable and with limited computing power and bandwidth. Information from the physical world presents new types of attack vector that can affect more than just data. Existing offerings do not typically take advantage of modern encryption, authentication and authorization security techniques. These solutions often use soft-keys easily extractable from firmware by an attacker, or communicate via networking protocols that use vulnerable pre-shared keys. We present an entirely new blockchain-based wireless security system that relies on hardware-secured key material and takes advantage of modern public key cryptography.

\textbf{Open Standards}. The evolution of networking protocols and technologies have taught us that closed ecosystems and proprietary technologies fail. Helium is built on the principles of open source and open standards technologies. There are no proprietary chipsets, obscure modulation schemes, and no closed-source software. We believe deeply in the principles of decentralization, which requires that anyone anywhere be capable of not only participating in the network, but adding to and growing it with technology of their choosing.

\textbf{Cost Effective}. Access to data from the physical world should be as cheap and cost-effective as possible. This requires creating a market-driven economic model, low network building costs, and a new type of currency suited to micro-transactions. By enabling anyone anywhere to help build and charge for this network, the participants set the prices they are willing to accept and pay. Because everything is open, there are no arbitrary points at which to extract fees and premiums.

\textbf{Developer Driven}. We believe that machines need developer tools that are an order of magnitude better than those currently available. Whether an individual or business, it shouldn't require deep hardware, firmware, security, and wireless expertise to get going. Moving from prototype to full product should not need a completely new effort. Helium provides a set of SDK's, reference hardware and internet applications that make sending and receiving data securely with low power hardware simple and open.

\subsection{Key Components}

Helium is built around the following key components:

\begin{enumerate}
  \item \textbf{\emph{Proof-of-Coverage}}: we present a computationally-inexpensive \emph{Proof-of-Coverage} that allows miners to prove they are capable of providing wireless network coverage. We anchor these proofs using a \emph{Proof-of-Serialization} that allows miners to prove they are accurately representing time relative to others on the network in a cryptographically secure way.

  \item \textbf{Blockchain Network}: we demonstrate an entirely new purpose-built blockchain network built to service the \emph{Wireless Protocol} and provide a system for authenticating and identifying devices, providing cryptographic guarantees of data transmission and authenticity, offer transaction primitives designed around the wireless protocol, and more.

    \item \textbf{Wireless Protocol}: we introduce a new open-source and standards-compliant wireless network protocol, called \emph{WHIP}, designed for low power devices over extremely wide areas. This protocol is designed to run on existing commodity radio chips available from dozens of manufacturers with no proprietary technologies or modulation schemes required.

    \item \textbf{Geolocation}: we outline a system for interpreting the physical \emph{geolocation} of a device using WHIP without the need for expensive and power-hungry satellite location hardware. Devices are able to make immutable, secure, and verifiable claims about their location at a given moment in time which are recorded in the blockchain.
\end{enumerate}

\subsection{System Overview}

\begin{itemize}
    \item The Helium protocol is a \emph{Decentralized Machine Network} system built around a new wireless protocol (WHIP) on a purpose-built blockchain with a native token.
    \item Devices take the form of hardware containing a radio chip and firmware compatible with WHIP, and spend tokens by paying miners to send data to and from the internet.
    \item Miners earn tokens by providing wireless network coverage via purpose-built hardware which provides a bridge between WHIP and routers, which are internet applications.
    \item Devices store their private keys in commodity key-storage hardware and their public keys in the blockchain.
    \item Miners join the network by asserting their satellite-derived location, a special type of transaction in the blockchain, and staking a token deposit.
    \item Miners specify the price they're willing to accept for data transport and geolocation, and devices specify the price they are willing to pay. Miners are paid once they prove they have delivered data to the devices' specified internet endpoint.
    \item Miners can participate in the creation of new blocks in the blockchain, for which they are rewarded newly minted Helium. A miners' probability of mining the next block is approximately equal to the amount of wireless network coverage being provided.
    \item The blockchain employs \emph{Proof-of-Coverage} to guarantee that miners are correctly representing the amount of wireless network coverage they are creating.
\end{itemize}

[Figure \ref{fig:system}] shows a visual representation of the Helium network.

\begin{figure*}[ht]
    \begin{center}
          \includegraphics[width=\textwidth]{schematic.eps}
          \caption{\emph{System Overview}}
          \label{fig:system}
     \end{center}
\end{figure*}

\section{The Helium DMN}

We introduce the Helium Decentralized Machine Network (\verb|DMN|). The \verb|DMN| provides wireless access to the internet for devices by way of multiple independent miners, and outlines a network and wireless protocol specification by which participants in the network should conform. Devices pay this network of miners for sending data to and from the internet, and miners are paid for continuously providing network coverage and delivering device data to the internet.

\subsection{Participants}

Any user can participate as a Device, a Miner, or a Router.

\begin{itemize}
    \item \emph{Devices} pay to send encrypted data to and from the internet via the \verb|DMN| using hardware compatible with the Helium wireless protocol, called \emph{WHIP} [Section \ref{whip}]. In geographies with a sufficient number of miners, devices can pay several miners to geolocate themselves without needing satellite location hardware. Data sent from devices is \emph{fingerprinted}, and that fingerprint stored in the blockchain.
    \item \emph{Miners} provide wireless network coverage to the network via purpose-built hardware, called gateways [Section \ref{gateways}], which provide a long-range bridge between WHIP and the internet. Users join the network as miners by purchasing or building a gateway that conforms to the wireless protocol, and \emph{staking} a token deposit proportional to the density of other miners operating in their area [Section \ref{staking}]. Miners participate in the \emph{Proof-of-Coverage} [Section \ref{poc}] process to prove that they are continuously providing wireless network coverage that devices can use. Miners join the network with a score [Section \ref{scores}] that diminishes as blocks pass without valid proofs being submitted. Miners are eligible to mine new blocks in the blockchain, and receive the block reward and transaction fees for any transactions included in the block once mined. As a miners score drops their probability of mining a block and earning the reward diminishes.
    \item \emph{Routers} are internet applications that receive encrypted device data from miners. Routers are the termination point for device data encryption. Devices record to the blockchain which routers miners should send their data, such that any gateway on the network can send any devices data to the appropriate router. Routers are responsible for confirming to the network that device data was delivered to the correct destination and that the miner should be paid for their service.
\end{itemize}

\subsection{Blockchain} \label{blockchain}

The Helium blockchain is a new type of ledger designed to provide a cost-effective way to run application logic core to the operation of a \verb|DMN|, store immutable device data fingerprints, and furnish a transaction system. We will refer to this as the Blockchain, $B$. $B$ is an immutable append-only list of transactions that achieves consensus by verifying \emph{Proofs-of-Coverage} [Section \ref{poc}]. Users internal and external to the \verb|DMN| have access to $B$, which is a new blockchain network built from scratch specifically for the \verb|DMN|.

$B$ consists of blocks $b_n$, which contain a header and a list of transactions. There are several kinds of transactions, outlined in [Section \ref{transactions}]. Although the blocks in chain can be linearly ordered, its data structure is actually a directed acyclic graph.

As in other implementations, $b_n$ consist of a hash of the previous block in the chain, a set of transactions, and a proof. At a given epoch $t$ a block $b_t$ consists of the following:

\begin{center}
    \begin{tabular}{|c|}
    	 \hline
         Block Version \\
         \hline
         Block Height \\
         \hline
         Previous Block Hash \\
         \hline
         Transactions \emph{1..n} Merkle Hash $T_t$ \\
         \hline
         \emph{Proofs-of-Coverage} \\
         \hline
         \emph{Proof-of-Serialization} \\
         \hline
    \end{tabular}
\end{center}

Due to the fact that miners are only able to add transactions to the block during the early phases of the mining cycle or that the block may be full, the miner holds pending transactions that it has seen, but that do not appear on the main chain, in a temporary storage area, called the \emph{mempool}. The mempool is consulted every time a new block is constructed, and the most valuable transactions for the miner are included in the new block. Because each miner has a different set of incentives, network topology and resources the mempools may not be consistent between any two miners.

As the \emph{Proof-of-Coverage} [Section \ref{poc}] is valuable to the network, we store as many $b_n$ and their associated proof to $B$ as \emph{Uncle Blocks}, $U_n$. $U_n$, as described in the \emph{Greedy Heaviest-Observed Sub-Tree (GHOST)}~\cite{ghost} paper and implemented in Ethereum~\cite{ethereum}, allow a miner to earn block rewards even if their submitted block did not become the tip of the chain. $U_n$ help the winning chain accumulate `weight' in terms of both the length and quality of the chain, but also including the amount and quality of $U_n$ and their associated proofs. This means that longer chain forks, either mined maliciously or on the smaller side of a partitioned network, will not be selected over a shorter, weightier chain. This also means that valuable proofs of work aren't lost and can be used by the chain to calculate trust.

Blocks are given a \emph{score} that is used as part of the consensus protocol to determine which block should be considered the tip of the chain. The score is based on the \emph{Proof-of-Coverage} and the score of $U_n$ contained within the submitted block. The consensus protocol is outlined in detail in [Section \ref{consensus}].

%\begin{figure*}[h]
%    \begin{center}
%          \includegraphics[width=\textwidth]{chain.eps}
%          \caption{\emph{A visualization of the Helium blockchain}}
%          \label{fig:chain}
%     \end{center}
%\end{figure*}

\subsection{Protocol}

In this section we provide an overview of the Helium \verb|DMN| and the functions that Devices, Miners and Routers play in the system.


\subsubsection{Device Cycle}

We provide a brief overview of the device cycle and the functions available to devices on the network in Cycle~ref{cycle:device}

\begin{algorithm}[!htb]
  \SetAlgorithmName{Cycle}{List of Lifecycles}
  \DontPrintSemicolon
  \SetKwProg{Device}{\BlankLine Device}{}{}
  \caption{Device Cycle Overview}\label{cycle:device}

  \Device{at any time} {
    Send data \;
    Receive data \;
  }

  \Device{when provisioning} {
    Generate keypair \;
    Input configuration information \;
    Store key material \;
    Output public key material \;
  }
\end{algorithm}
\FloatBarrier

\begin{description}
  \item [Provisioning] A device is provisioned on the \verb|DMN|.

    Devices join the network by being programmed with keying material by their owner. This key material includes a private key known only by the device, the public key of the root-of-trust for the organization and a 64-bit MAC address.The MAC address consists of 32 bits of an Organizationally Unique Identifier (OUI) and 32 bits of an organizationally managed device identifier. Via an out of band mechanism the device's public key is added to the organization's device registry, indexed by the MAC address. Details of the management of device identifiers and keys are implementation defined, and out of scope of this document.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Prov}{\BlankLine Provision}{}{}
      \SetKwFunction{Store}{Store}
      \SetKwFunction{Encrypt}{Encrypt}
      \caption{Device Provisioning}\label{proto:device.provision}

      \Prov{device D} {
        $E_k, E_{pk}, \leftarrow $ generate public/private keypair \;
        Input ${ID}_d \leftarrow $ $ \ll device ID:32 \gg $ \;
        Input $R_k \leftarrow $ public key for organization \;
        Input ${OUI}_d \leftarrow $ $ \ll organization ID:32 \gg $ \;
        \BlankLine
        Securely \Store{$E_k$, $E_{pk}$, $R_k$, ${OUI}_d$, ${ID}_d$} \;
        \BlankLine
        Output $E_{pk}$ \;
      }
    \end{algorithm}
    \FloatBarrier

  \item [Send] A device sends data to a router on the internet, via a miner.

    Devices can send data to their specified router on the internet by paying miners Helium tokens.
    A device initiates the sending process by broadcasting a packet via the wireless protocol. When a device broadcasts a packet any miners in a reasonable geographic area hear it. Each packet header contains the device's MAC address, and miners inspect the blockchain using this address to determine which routers are listed for the OUI component of the MAC address. See the Miner Deliver Protocol~[\ref{proto:miner.data.deliver}].

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \SetKwProg{Send}{\BlankLine Send}{}{}
      \SetKwFunction{SignalData}{SignalData}
      \SetKwFunction{Data}{Data}
      \SetKwFunction{Transmit}{Transmit}
      \caption{Device Send Data}\label{proto:device.data.send}

      \Send{from device ${ID}_d$, data A} {
        $M \leftarrow $ \SignalData{A} \;
        \Transmit{M} \;
        \BlankLine

        $A_e \leftarrow $ \Encrypt{A, private key $E_{pk}$} \;
        $B \leftarrow $ \Data{${OUI}_d$, ${ID}_d$, $A_e$} \;
        \Transmit{B} \;
        \BlankLine

        \Switch{Wait for response} {
          \Case{signaling message M} {
            Recieve Data. See Protocol~[\ref{proto:device.data.recv}]
          }
          \Case{timeout} {sleep}
        }
      }
    \end{algorithm}
    \FloatBarrier

  \item [Receive] After a device has performed a Send, the device will listen for a response.

    The response can be a single acknowledgement or a queued up command or data packet. If the device gets a signalling packet describing a downlink message, it will stay awake until the entire packet has been received, otherwise it is free to turn its radio off or go into power-saving mode.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \SetKwFunction{Decode}{Decode}
      \caption{Device Receive Data}\label{proto:device.data.recv}

      \Recv{at device ${ID}_d$, signaling message M} {
        Size $S \leftarrow $ \Decode{M} \;
        \Switch{Receive Data D} {
          \Case{success} {hand to application}
          \Case{timeout} {sleep}
        }
      }
    \end{algorithm}
    \FloatBarrier

\end{description}


\subsubsection{Miner Cycle}\label{mining}

We provide a brief overview of the mining cycle and the functions available to miners on the network in Cycle~[\ref{cycle:miner}]

\begin{algorithm}[!htb]
  \SetAlgorithmName{Cycle}{List of Lifecycles}
  \DontPrintSemicolon
  \SetKwProg{Miner}{\BlankLine Miner}{}{}
  \caption{Miner Cycle Overview}\label{cycle:miner}

  \Miner{At every epoch \emph{blocktime}} {
    Construct a block\;
    Add transactions from non-winning blocks\;
    Add transactions from mempool\;
    Construct \emph{Proof-of-Coverage}\;
    Construct \emph{Proof-of-Serialization}\;
    Submit block to peers\;
  }

  \Miner{At any time} {
    Receive transactions\;
    Receive block\;
    Receive coverage challenge\;
    Receive serialization challenge\;
    Receive data from device\;
    Receive data from router\;
  }

  \Miner{when joining} {
    Construct transaction with address, public key, and payee\;
    Construct transaction with location\;
    Submit transactions to a random peer\;
  }

  \Miner{on location change} {
    Construct transaction with new location\;
    Submit transaction to a ramdom peer\;
  }
\end{algorithm}
\FloatBarrier


\begin{description}
  \item [Join] A miner joins the network.

    Joining the network is simply adding the miner's address/public key and its 'owner' (the address mining rewards should be paid to) to the blockchain.

  \item [Assert Location] A miner asserts their GPS location to the network.

    Asserting a location indicates that the miner is claiming it is at particular physical coordinates. To assert a location, a dynamic stake is required. The value of the dynamic stake is related to a parabolic curve where the x axis represents the density of the existing network in that area and the y axis is the staking multiplier. Thus for singleton gateways, or very small networks, the staking requirements are high, once the network approaches an ideal density the stake approaches the lowest point and then as the density of the network exceeds the ideal the staking cost increases. This disincentivizes \emph{Alternate Reality Attacks} because asserting a location in an unpopulated region with no way to confirm network presence is very expensive. Similarly constructing a 'mining warehouse', where an extremely high density of miners is deployed also becomes very expensive. Only miners that have asserted a location are allowed to mine. Assertions of location can be retracted and the stake recovered, or they can be confiscated in cases of misbehavior.

  \item [Receive Transactions] A miner connects to the peer-to-peer network and listens for clients publishing transactions to the network.

    Transactions contain fees that the miner can claim if it publishes the winning block [Section \ref{fees}]. The miner can also capture transactions from blocks published to the peer-to-peer network that did not win as described in Protocol~[\ref{proto:miner.block.recv}].

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \caption{Miner Receive Transactions}\label{proto:miner.trans.recv}

      \Recv{transactions} {
        Add transactions to mempool\;
      }
    \end{algorithm}
    \FloatBarrier

  \item [Construct Block] The miner takes the current head of the chain and begins to construct a new block.

    The new block contains the hash of the previous block (the current head), the block height (how many blocks are in the chain between this block and the genesis block) and a set of transactions from the mempool. The set of transactions are added to a merkle tree and the root hash is also stored.

  \item [Challenge] A miner begins the \emph{Proof-of-Coverage} process by becoming a Challenger.

    The miner uses their public key to sign a digest of their partially completed block to obtain some verifiable randomness. This randomness is used to choose the Target. Once the Target is selected the proof of coverage is constructed [Section \ref{poc}]

  \item [Receive Radio Challenge] A miner receives a \emph{Proof-of-Coverage} radio transmission.

    The miner receives a radio challenge. The challenge contains the original challenger, and encrypted data. The encrypted data includes a secret, a next block of data, and the time at which to transmit that remaining data.

    The miner delivers a signed receipt of the secret, next transmission time, and the perceived signal strength to the challenger. Finally, it transmits the next data block at the indicated time to complete the challenge.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \SetKwFunction{Decrypt}{Decrypt}
      \SetKwFunction{Deliver}{Deliver}
      \SetKwFunction{Transmit}{Transmit}
      \SetKwFunction{Sign}{Sign}
      \caption{Miner Receive Radio Challenge}\label{proto:miner.recv.challenge.radio}

      \Recv{radio challenge envelope (challenger C, data O), at time $\beta$, signal strength $\upsilon$} {
        \Switch{\Decrypt(O, private key $E_{pk}$)} {
          \Case{Secret $S$, NextTime $\psi$, Remainder $R$} {
            $K_s \leftarrow \ll S:64, \beta:32, \upsilon:32 \gg $\;
            $B \leftarrow \Sign{$K_s$, $E_{pk}$} $\;
            \Deliver{C, B}\;
            At time $\psi$ \Transmit{(C, R)}\;
          }
          \lOther{drop challenge}
        }
      }
    \end{algorithm}
    \FloatBarrier

  \item [Receive Serialization Challenge] A miner will receive serialization challenges from other miners trying to construct a proof.

    The miner will returned a signed envelope including the challenge and the current time. The challenging miner will use a number of these serialization challenges to prove that the final \emph{Proof-of-Coverage} happened at a given time.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \SetKwFunction{Time}{Time}
      \SetKwFunction{Sign}{Sign}
      \caption{Miner Receive Serialization Challenge}\label{proto:miner.recv.challenge.serialization}

      \Recv{serialization challenge K}{
        $T \leftarrow \Time{milliseconds} $\;
        $B \leftarrow \ll K:64, T:64 \gg $\;
        $R \leftarrow \Sign{B, $E_{pk}$} $\;
        Respond $R$ to sender\;
      }
    \end{algorithm}
    \FloatBarrier

  \item [Deliver] A miner delivers data from a device to a router on the internet.

    Once a miner has received a packet from an end device, along with the precise timestamp it was received, it looks up the routers for the organization owning that device and offers the packet to one of those routers, for a fee. The router can accept the fee and return a \emph{chit}, or make a counter offer. The router can also reject the offer if it already has a copy of the packet or it is unwilling to pay the offered price. A router may pay for several copies of the packet if it wishes to solve for the position of the end device. See the corresponding Router Receive Data Protocol~[\ref{proto:router.offer.recv}].

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \SetKwFunction{FindRouters}{FindRouters}
      \SetKwFunction{CalculateDeliverFee}{CalculateDeliverFee}
      \SetKwFunction{Sign}{Sign}
      \SetKwFunction{Deliver}{Deliver}
      \SetKwFunction{Hash}{Hash}
      \SetKwFunction{Transaction}{Transaction}
      \SetKwFunction{AcceptableOffer}{AcceptableOffer}
      \caption{Miner Deliver Device Data}\label{proto:miner.data.deliver}

      \Recv{at miner M, timestamp T, from device D, data A, data signature $S_a$} {
        Router $R \leftarrow R \in $ \FindRouters{D} \;
        Fee $F \leftarrow $ \CalculateDeliverFee{R, D, A} \;
        Hash $H_a \leftarrow $ \Hash{A} \;
        Offer $O \leftarrow $ \Sign{$\ll ID_d, H_a, S_a, F \gg $, $E_{pk}$} \;
        \Switch{\Deliver{R, O}} {
          \Case{$Chit$}{
            Validate $Chit$\;
            \Deliver{R, T, A}\;
            $T \leftarrow $ \Transaction{redemption, M, Chit} \;
            Submit $T$ to peers\;
          }
          \Case{counter offer $O_c$, fee $F_c$} {
            Validate $O_c$
            \Switch{\AcceptableOffer{$O_c$}} {
              \Case{accept} {
                Restart offer with fee $F_c$\;
              }
              \lCase{decline} {
                drop A \;
              }
            }
          }
          \lOther{drop A}
        }
      }
    \end{algorithm}
    \FloatBarrier


  \item [Receive Data] A miner receives data from a router on the internet for delivery to a device.

    In response to an uplink packet offer, the router can also respond with a downlink packet, with an attached \emph{chit} to have the gateway deliver a downlink packet to the end device. The end device will listen for a downlink packet after transmitting.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \SetKwFunction{Transmit}{Transmit}
      \SetKwFunction{Transaction}{Transaction}
      \caption{Miner Receive Router Data}\label{proto:miner.data.receive}

      \Recv{at miner M, data A, signature $S_a$, for device $ID_d$, with $Chit$} {
        \emph{This can only happen in response to G delivering data to R}
        Validate data $A$ \;
        Validate $Chit$\;
        \Transmit{$ID_d$, A} \;
        $T \leftarrow $ \Transaction{redemption, M, $Chit$} \;
        Submit $T$ to peers\;
      }
    \end{algorithm}
    \FloatBarrier


  \item [Submit Block] A miner submits a new candidate block to the network containing a \emph{Proof-of-Coverage}.

    Once a miner has completed a block it publishes it to its p2p peers.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Submit}{\BlankLine Submit}{}{}
      \caption{Miner Block Submit}\label{proto:miner.block.submit}

      \Submit{block} {
        Gossip block to peers\;
      }
    \end{algorithm}
    \FloatBarrier

  \item [Receive Block] A miner receives blocks from one or more of its peers.

    If the received block is considered valid and has not seen it before, the miner will gossip it to its peers. Blocks are ranked in terms of quality; how valuable the proof-of-coverage was, how many transactions were in the block, how many uncles were included and how close to the ideal blocktime was the time difference from the previous block. After a settling period each miner chooses its preferred 'best' block and mines the next block on top of that.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \caption{Miner Block Receive}\label{proto:miner.block.recv}

      \Recv{block} {
        Add sender to peer list\;
        Verify block\;
        \Switch{Add block to chain}{
          \Case{success}{
            Gossip block to peers\;
            Harvest losing block transactions\;
          }
          \Case{unchanged}{
            ignore block\;
          }
        }
      }
    \end{algorithm}
    \FloatBarrier

\end{description}


\subsubsection{Routing Cycle}

We provide a brief overview of the routing cycle and the functions available to routers on the network.

\begin{algorithm}[!htb]
  \SetAlgorithmName{Cycle}{List of Lifecycles}
  \DontPrintSemicolon
  \SetKwProg{Router}{\BlankLine Router}{}{}
  \caption{Router Cycle Overview}\label{cycle:router}

  \Router{At any time} {
    Receive Data Offer \;
    Receive Data \;
  }

  \Router{after receving} {
    Send Device Data \;
  }
\end{algorithm}
\FloatBarrier


\begin{description}

    \item [Receive Data Offer] A router receives an offer to deliver a device packet.

      This offer includes the MAC address, the hash of the payload, the device's signature of the packet and the proposed delivery fee as described in Protocol~[\ref{proto:miner.data.deliver}]. The router can determine the authenticity of the packet, know if it already has a copy of the packet, and decide on if the delivery price is acceptable.

      A router can accept the offer, decline it or make a counter offer to the miner. When accepting an offer, the router replies with a \emph{chit} that serves as both a payment as well as an anchoring the proof the packet existed at that point in time.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \SetKwFunction{AcceptableOffer}{AcceptableOffer}
      \SetKwFunction{Sign}{Sign}
      \caption{Router Receive Data Offer}\label{proto:router.offer.recv}

      \Recv{from miner M, device $ID_d$, data signature $S_a$, hash $H_a$, fee F} {
        Verify device $ID_d$ \;
        \Switch{\AcceptableOffer{F, $ID_d$, $S_a$, $H_a$}}{
          \Case{counter $F_c$} {
            Offer $O \leftarrow $ \Sign{$\ll ID_d, H_a, S_a, F_c \gg $, $E_{pk}$} \;
            \Deliver{M, O}
          }
          \Case{accept} {
            Chit $C \leftarrow $ \Sign{$ \ll accept, ID_d, H_a, F \gg $, $E_{pk}$} \;
            \Deliver{M, C} \;
          }
          \Case{decline} {
            Decline $D \leftarrow $ \Sign{$ \ll decline, ID_d, H_a, F \gg $, $E_{pk}$} \;
            \Deliver{M, D} \;
          }
        }
      }
    \end{algorithm}
    \FloatBarrier


    \item [Receive Data] A router receives a device packet.

      Once an offer from a miner is accepted, it will send the device packet to the router. The router may accept the same packet multiple times from different miners to perform geo-location on the device.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Recv}{\BlankLine Receive}{}{}
      \caption{Router Receive Data }\label{proto:router.data.recv}

      \Recv{from miner M, device $ID_d$, data signature $S_a$, data A} {
        Verify data $A$ \;
        handle device data \;
      }
    \end{algorithm}
    \FloatBarrier


    \item [Send Data] On receipt of an offer or data a router can send data to the device.

      Regardless of the accept/decline of the actual packet, the router can leverage the fact that it knows the gateway is in-range of the end-device to send a message down to it. Along with the packet to send, the router includes a \emph{chit} to pay for the transmission.

    \begin{algorithm}[!htb]
      \SetAlgorithmName{Protocol}{List of Protocols}
      \DontPrintSemicolon
      \SetKwProg{Send}{\BlankLine Send}{}{}
      \SetKwFunction{Sign}{Sign}
      \SetKwFunction{Hash}{Hash}
      \SetKwFunction{CalculateDeliverFee}{CalculateDeliverFee}
      \SetKwFunction{Deliver}{Deliver}
      \caption{Router Send Data }\label{proto:router.data.send}

      \Send{using miner M, for device $ID_d$, data A} {
        $S_a \leftarrow $ \Sign{A, $E_{pk}$} \;
        $H_a \leftarrow $ \Hash(A) \;
        Fee $F \leftarrow $ \CalculateDeliverFee{$ID_d$, A} \;
        Chit $C \leftarrow $ \Sign{$ \ll deliver, ID_d, H_a, F \gg $, $E_{pk}$} \;
        \Deliver{M, $ID_d$, A, $S_a$, Chit} \;
      }
    \end{algorithm}
    \FloatBarrier


\end{description}

\section{Physical Implementation}

In addition to the blockchain network, Helium is a \emph{physical} wireless network instantiation. The participants in the network, from a physical hardware perspective, can be thought of as follows:

\begin{description}
        \item [Wireless Protocol] The wireless network uses a new open wireless protocol, called \emph{WHIP}. WHIP is a long-range, low-power, wireless network protocol suitable for use with commodity open-standards hardware. WHIP compatible hardware can communicate over many square miles in dense urban environments or hundreds of square miles in rural settings. WHIP compatible hardware can also last for several years using standard batteries. WHIP uses strong public key cryptography and authentication occurs using the Helium blockchain, with end-to-end encryption.

        \item [Gateways] Gateways are physical network devices that provide wide-area wireless coverage and participate in the blockchain network. Gateways transmit data back and forth between routers on the internet and devices while generating \emph{Proofs-of-Coverage} for the blockchain network [Section \ref{poc}]. Gateways are manufactured using commodity open-standards components with no proprietary hardware. Gateways can cooperate and geolocate devices using the wireless network without any additional required hardware. Each Gateway can support thousands of connected devices, and provide coverage over many square miles. Miners operating gateways specify the price they are willing to accept for transport and geolocation services for devices.

        \item [Devices] Devices exist in the form of hardware products that contain a WHIP-compatible radio transceiver and communicate with gateways on the wireless network. WHIP is designed to facilitate low power data transmission and reception, so typically devices would exist in the form of battery-powered sensors that can live for several years using standard batteries (although mains-powered devices also work quite well). Devices can exist in a variety of forms, depending on the product or use case, and a variety of transmission and reception strategies can be employed to optimize for transmission/reception frequency or battery life. Device manufacturers should use hardware-based key storage which can securely generate, store, and authenticate public/private key pairs without leaking the private key.
\end{description}

In this section, we expand on the components of the wireless network.

\subsection{Wireless Protocol (\emph{WHIP})}\label{whip}

\begin{description}
        \item [Motivation] Several Low Power Wide Area Network (LPWAN) technologies are available today. These wireless technologies focus on creating extremely long-range, low-power internet communication for sensors and other smart devices. Typically these technologies trade throughput for range, with data rates as low as 18~bits~per~second (bps) and range measured in miles. In comparison, a typical WiFi network has significantly higher data rates but ranges limited to only a few hundred feet. Several of these new technologies, such as LoRa~\cite{lora} and RPMA~\cite{rpma}, have gained good traction and there are many commercial products available compatible with these systems. However, we believe that the wireless network of the future should use non-proprietary protocols and modulation schemes and that participants in this ecosystem should have the freedom to choose between competing hardware vendors. We do not consider an open alliance built on top of proprietary hardware to be an acceptable compromise. While there are many open-standard wireless networking stacks, such as IEEE~802.15.4~\cite{ieee802_15_4} used in the first generation of Helium wireless products, none meet our extremely long range and low power criteria. It is this lack of open solutions that drove the creation of a new protocol.

        \item [Outline] We introduce a new open-source Low Power Wide Area Network (LPWAN) protocol called \emph{WHIP}. WHIP is a highly secure, long range, low power wireless network protocol that is compatible with any Frequency Shift Keying (FSK) radio transceiver operating in the sub-GHz unlicensed frequency spectrum. Authentication with the wireless network uses modern public-key encryption and NIST~P-256 ECC key pairs, with the public keys for all participants stored in the blockchain.

        FSK is a simple and widely supported modulation format which easy to implement and has excellent resistance to RF noise. There are dozens of vendors implementing FSK radio transceivers compatible with WHIP, such as Texas Instruments, Microchip, and Silicon Labs.

        WHIP is a \emph{narrowband} wireless protocol which creates several channels within the unlicensed spectrum and employs frequency hopping to hop between channels. Typically frequency hopping requires a complex time-synchronized system that is limited in capacity, however, devices using WHIP do not need to coordinate with gateways on channel selection as gateways are capable of hearing all channels within the available spectrum at any time. We choose narrow-band to accomplish the following goals:

        \begin{description}
                \item[Spectral Efficiency] it is necessary to operate within unlicensed RF spectrum very efficiently. RF is a shared, limited resource, and therefore a focus on efficiency to increase capacity and improve robustness is a must.
                \item[Co-Existence Performance] as the number of devices and networks increase, the ability to operate in \emph{noisy} RF environments without interference is a critical consideration.
                \item[Range] narrowband allows for extremely long-range communications, with data rates that scale both up and down depending on the density of gateways.
        \end{description}

        \item [Implementation] WHIP supports several data rates, channel bandwidths, and error-correction techniques. Gateways and devices dynamically negotiate the combination of these options using a \emph{signalling packet} delivered at the lowest bandwidth and symbol rate to ensure maximum range for the initial communication.
\end{description}

The full WHIP specification will be made available by the Helium Alliance.

\subsection{Gateways}\label{gateways}

Gateways are physical network devices operated by miners that create wireless RF coverage over wide areas. They transmit data back and forth between routers on the Internet and devices on the network, process blockchain transactions, and create \emph{Proofs-of-Coverage} for the blockchain network [Section \ref{poc}]. Gateways can connect to the Internet using any TCP/IP capable backhaul, such as Ethernet, WiFi or Cellular. Each gateway contains a radio frontend chip capable of listening to several MHz of radio spectrum at a time, and is able to hear all network traffic transmitted within that spectrum. In this configuration modulation and demodulation is done in software, which is typically referred to as a \emph{Software Defined Radio (SDR)}. The benefit of this structure is that gateways can hear any device traffic transmitted within the frequency range, and no synchronization between the gateway and device needs to occur. This allows devices to remain inexpensive and relatively simple, and reduces wireless protocol overhead. If a miner wishes to minimize their gateway hardware costs, synchronized frequency hopping schemes are also permitted within the specification as a cheaper alternative to a more expensive radio frontend.

Gateways require a GPS or GNSS transceiver to obtain accurate position and date/time information. This satellite-derived location will be used in conjunction with other techniques to verify that a gateway is in fact providing wireless network coverage in the location it claims. Because satellite location messages are easy to fabricate and do not necessarily prove that wireless RF coverage is being created, multiple mechanisms are required to validate this work as described in more detail in [Section \ref{poc}].

Satellite location information is also correlated with packet arrival events to provide \emph{Time Differential of Arrival (TDoA)} location for devices if multiple gateways observe the same packet. This allows devices to physically locate themselves without requiring a GPS/GNSS transceiver, and therefore provide accurate location data at a fraction of the battery life and cost of competing methods. This method is described in detail in [Section \ref{geolocation}].

Helium Systems Inc.\ will make both a complete open-source reference design and a finished product available for immediate participation in the network.

\subsection{Devices}\label{devices}

A \emph{device} is any wireless hardware capable of communicating with gateways on the network. WHIP is designed to facilitate low power data transmission and reception, so typically devices would exist in the form of battery-powered sensors that can function for several years using standard batteries.

WHIP is designed such that devices can be manufactured using commodity hardware available from a wide variety of vendors, and for an extremely low-cost bill of materials (BOM). The technology in modern radio transceivers, such as the Texas Instruments CC1125 or STMicroelectronics S2-LP, enables extremely long-range network systems that can be built without the need for proprietary modulation schemes or physical layers. Some of these radios are available for around \$1 at reasonable volumes.

Each device will use the Microchip ECC508A or equivalent hardware-based key storage device, which is able to securely generate, store, and authenticate public/private \emph{NIST P-256 ECC} \cite{nist} key pairs without leaking the private key. In addition, a wide array of defense mechanisms prevent logical attacks on the encrypted data between the key storage device and its host device, along with physical protections on the security device itself. Users program their key storage device as part of the onboarding process defined in the WHIP wireless specification using a simple SDK\@.

\subsection{Routers}

Routers are internet-deployed applications that receive packets from devices via gateways and route them to appropriate destinations such as an HTTP or MQTT endpoint. Routers also act as \emph{full nodes} for the blockchain network [Section \ref{full-nodes}].

There are several functions that routers serve on the network, which include:

\begin{itemize}
    \item Authenticating devices with the wireless network
    \item Receiving packets from gateways and routing them to the Internet
    \item Delivering downlink messages, including OTA updates, to devices via gateways
    \item Providing delivery confirmations to ensure transport transactions are honest
    \item Providing authentication and routing mechanisms into third-party cloud services such as Amazon AWS or Microsoft Azure
    \item Storing and making available a full copy of the blockchain ledger
\end{itemize}

When a gateway receives a data packet from n device on the network, it will query the blockchain to determine which router to use given the devices network address. Anyone anywhere is free to host their own router and define their devices traffic to be delivered there by any gateway on the network. This allows users of the network to essentially create VPN-like functionality whereby encrypted data is delivered only to a router (or set of routers) that they specify and can optionally host themselves.

Routers can implement a system called a \emph{Channel} which handles the authentication and routing of data to a specific third party Internet application, such as Microsoft's Azure IoT Hub. These channel implementations can take advantage of a devices onboard hardware security to create a secure, hardware-authenticated connection to a third party which would otherwise be difficult to implement directly on an embedded microcontroller. Helium will make available an open source reference implementation of a Channel that can be used to build additional interfaces to Internet services.

Helium Systems Inc hosts a high-availability cloud router for anyone to use, and also provides and maintains an open-source router that is available either as source code or a binary package for a variety of operating systems and distributions.

The protocol specification required for implementing a router is defined in the WHIP Wireless Specification document that will be made available by the Helium Alliance.

\subsection{Geolocation}\label{geolocation}

WHIP-compatible gateways include hardware and software to enable not only location of the gateway (via GPS/GNSS) but also hardware and software to triangulate the location of devices. There are a number of techniques used by positioning systems without the use of GPS, which include Received Signal Strength Indication (RSSI), Time of Arrival (ToA), and Time Differential of Arrival (TDoA). We use TDoA to achieve the most accurate geolocation.

The approximate flow for accomplishing geolocation is as follows:

\begin{enumerate}
        \item A device, $D$, broadcasts a packet $P$ containing arbitrary data via the wireless network
        \item Several miners, $M_n$, hear $P$, and record a timestamp $T_n$ of their reception time of $P$
        \item $T_n$ is determined based on the nanosecond time received via GPS, and stamped using raw radio sample data received by the gateway radio frontend
        \item $P$ and $T_n$ are delivered to the router $R$ belonging to $D$ by $M_n$
        \item $R$ has now received several copies of $P$, each of which has a slightly varying value of $T_n$, and the location of each $M_n$ is known in the blockchain
        \item $R$ can now solve for the location of $D$ using the location of $M_n$ and the nanosecond variances in $T_n$
\end{enumerate}

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=\columnwidth]{tdoa.eps}
          \caption{\emph{Geolocation via TDoA}}
          \label{fig:tdoa}
     \end{center}
\end{figure}


If a sufficient density of $M_n$ hear $P$, the location of $D$ can be derived down to a few meters. Because of the expense and power consumption of a typical GPS module, and the fact that they require a view of the sky, providing geolocation as a network service makes devices cheaper, more power efficient, and able to located accurately indoors. Additionally, because these data transmission events occur in the context of a blockchain, unforgeable cryptographic proof of location for a device can be obtained. Devices being able to prove they were in a specific place at a specific time has tremendous potential for a wide variety of machine applications.

We refer the interested reader to\cite{tdoa} for a detailed description of TDoA techniques.

\section{\emph{Proof-of-Coverage} \& \emph{Proof-of-Serialization}}\label{poc}

In the Helium network, miners must prove that they are providing wireless network coverage that devices are able to use to communicate with the internet. Miners do this by complying with the \emph{Proof-of-Coverage} protocol which the blockchain network and other miners audit and verify. We use a \emph{Proof-of-Serialization} to ensure that miners are correctly representing their time in relation to others on the network, and obtain cryptographic proof of dishonest behavior. Several components of the Helium network, such as blocks in the blockchain, use \emph{Proof-of-Serialization} as a cryptographic ``anchor'' that root those occurrences  with a cryptographic time proof. With a combination of \emph{Proof-of-Coverage} and \emph{Proof-of-Serialization} we can obtain cryptographic proof of the approximate location and time of events occurring within Helium.

In this section we outline the motivation and implementation for \emph{Proof-of-Coverage} and \emph{Proof-of-Serialization}.

\subsection{Motivation}

Most existing blockchain networks such as Bitcoin~\cite{bitcoin} and Ethereum~\cite{ethereum} use a \emph{Proof-of-Work} system that relies on an algorithmic puzzle that is asymmetric in nature. These proofs are extremely difficult to generate, but simple for a third party to verify. Security on these networks is achieved by the network-wide \emph{consensus} that the amount of computing power required to generate a valid proof is difficult to forge, and as subsequent blocks are added, the cumulative difficulty of the chain becoming realistically impossible to fabricate.

These computation-heavy proofs are, however, not otherwise \emph{useful} to the network. We define useful as work that is valuable to the network beyond securing the blockchain. While there have been attempts in other networks to turn mining power into something useful, such as Ethereum executing small programs, the majority of the work is not useful or reusable. The mining process is also extremely wasteful, as the determining factor in the work is typically computational power which consumes massive amounts of power and hardware to execute.

The proofs used in Helium must be resistant to \emph{Sybil Attacks} in which dishonest miners create pseudonymous identities and use them to subvert the network and gain access to block rewards to which they should not be entitled. This is a particularly difficult attack vector to manage in a physical network like Helium. We must also be resistant to a new attack vector: \emph{Alternate Reality Attacks} exist where a dishonest group of miners are able to simulate that wireless network coverage exists in the physical world when it in fact does not. An example of this would be running the mining software on a set of virtual machines and simulating GPS coordinates and RF networking.

We later propose a consensus protocol [Section \ref{consensus}] that uses \emph{Proof-of-Coverage} to both secure the blockchain and provide an extremely useful service to the network; providing wireless network coverage that devices can use to send data to and from the internet.

\subsection{Inspiration}

\emph{Proof-of-Coverage} (\verb|PoC|) is an innovative proof which allows miners to prove that they are providing wireless network coverage $W$ in a specific region to a challenger, $C$. \verb|PoC| is an interactive protocol where a set of targets $T_n$ assert that $W$ exists in a specific GPS location $L$ and then convinces $C$ that $T_n$ are in fact creating $W$ and that said coverage must have been created using the wireless RF network. \verb|PoC| is the first such protocol that attempts to prove the veracity of miners in a physical space, and then use it to achieve consensus on a blockchain network.

With \verb|PoC| we aim to solve for the following:

\begin{itemize}
    \item Our goal is to prove that miners are operating radio frequency (RF) hardware and firmware compatible with the wireless protocol
    \item Our goal is to prove that miners are located in the geography they claim by having them communicate via RF
    \item Our goal is to correctly identify which reality is honest when there is a conflict
\end{itemize}

\emph{Proof-of-Coverage} is inspired by the \emph{Guided Tour Protocol (GTP)}~\cite{gtp} which devises a system for denial of service prevention by requiring a client $c$ to make a request to a variety of ``tour guide'' computers $G_n$ in order to gain access to a server $s$. The tour guides must be visited in a specific order and a hash of data exchanged which reveals the location of the next $G_n$ in order. Only after every $G_n$ has been visited can $c$ gain access to $s$.

Once $c$ gets to the last stop of the tour, it submits evidence of the first and last stop to $s$ who is able to verify that the first and last stops of the tour are correct without needing to contact $G_n$, and that $c$ could only know the first and last stops if it had completed the tour correctly.

While an extremely clever and innovative system, GTP is not directly suitable as a proof in our wireless network as radio frequency (RF) networking has limited range and therefore cannot communicate with peers anywhere on the network. We aim to construct a proof loosely based on the ideas presented in GTP, but applicable to our protocol.

We combine \emph{Proof-of-Coverage} with \emph{Proof-of-Serialization}---a proof that allows miners on the network to achieve cryptographic time consensus among decentralized clients. We aim to achieve rough time synchronization in a secure way that does not depend on any particular time server, and in such a way that, if a time server does misbehave, clients end up with cryptographic proof of that behavior.

\subsection{Constructing \emph{Proof-of-Coverage}}

This section describes the construction of the \emph{Proof-of-Coverage} protocol.

We aim to construct a proof that takes advantage of the following characteristics of radio frequency (RF) communication that are unique and different to internet communication:

\begin{enumerate}
    \item RF has limited physical propagation and therefore distance
    \item RF travels at the speed of light with (effectively) no latency
\end{enumerate}

Our goal is to verify whether miners in a physical region are acting honestly and creating wireless network coverage compatible with the Helium wireless protocol (WHIP). To do this, a challenger $C$ deterministically constructs a multi-layer data packet $O$ which begins at an initial target, $T_1$, and is broadcast wirelessly to a set of sequential targets, $T_n$, each of which are only able to decrypt the outer-most layer of $O$ if they were the intended recipient. Each target acknowledges receipt, $K_S$, back to $C$, removes their layer of $O$, $O$\textsubscript{l-n}, and broadcasts it for receipt by the next target. Essentially, an ``envelope of envelopes'' only openable by the intended recipient.

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=\columnwidth]{deconstruction.eps}
          \caption{\emph{Multi-Layer Data Packet Deconstruction}}
          \label{fig:poc-deconstruction}
     \end{center}
\end{figure}

\textbf{Selecting the Initial Target}. We aim to deterministically locate a geographic reference target, $T$, for the challenger, $C$. $T$ does not need to be geographically proximate to $C$. To locate $T$, $C$ uses a \emph{consistent hash ring} $\omega$, of potential miners. $\omega$ only contains miners eligible as targets as described in [Section \ref{mining}], and miners are allocated portions of $\omega$ that are inversely proportional to their score, increasing the probability of potentially dishonest miners being targeted. We refer the interested reader to \cite{hashing} for further reading on consistent hashing techniques. Given that a miners score is diminishing linearly over time [Section \ref{scores}], it is necessary to create this inverse relationship to give low-scoring miners an opportunity to participate in the process and increase their score. This diminishing score also incentivizes all the participants to send receipts to the challenger and broadcast the remainder of $O$. We seed verifiable randomness, $\eta$, into the selection process using a signed digest of the partial block from $C$ - thus, it is necessary for $C$ to have begun forming a new candidate block for the blockchain before the \emph{Proof-of-Coverage} process can begin [Section \ref{mining}].

\textbf{Constructing the multi-layer challenge}. Once $T$ has been selected, $C$ must construct a multi-layer challenge, $O$. $O$ is a data packet broadcast over the wireless network and received by geographically proximate targets $T_n$. Geographically proximate is defined as within a radius of $T$, a network value $T$\textsubscript{radius}. Each layer of $O$, $O_l$, consists of a three-tuple of $E\left(S, \psi, R\right)$, where $E$ is a secure public key encryption function, $S$ is a secret value, $\psi$ is the time to broadcast the next layer of the challenge and $R$ is the remainder of $O$ consisting of recursive three-tuples. The maximum number of $O_l$ is bounded by a network value, $O$\textsubscript{max}. 

The construction logic of $O$ is as follows:

\begin{enumerate}
  \item A set of candidates, $T_n$, are constructed such that all members of $T_n$ are within a contiguous radio network that also contains $T$
  \item Two targets, $T_1$ and $T_L$, are selected by finding the highest scoring targets in $T_n$ furthest from $T$
  \item A weighted graph, $T_g$, is constructed from $T_n$ such that members of $T_g$ in radio range of each other are connected by an edge weighted by the value of \(1 - \Big({score(T_a) - score(T_b)}\Big)\)
  \item The shortest path between $T_1$ to $T$ to $T_L$ is computed using Dijkstra's algorithm\cite{dijkstra}
  \item A layer $O_l$ is created and added to $O$, and $S$ is encrypted with the public key of $T_1$ retrieved from the blockchain  
  \item This process repeats with additional layers added to $O$ until all $T_g$ have a layer $O_l$ included in $O$
\end{enumerate}

The resulting $O$ can be visually represented as the following:

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=\columnwidth]{o_construction.eps}
          \caption{Construction of $O$}
          \label{fig:poc-o_construction}
     \end{center}
\end{figure}

\textbf{Creating the Proof}. Once $O$ has been constructed, it is delivered to $T_1$ via the internet peer-to-peer network and immediately broadcast via the wireless network. The Helium wireless protocol is not a point-to-point system, so several miners within proximity of $T_1$ will hear $O$. As described prior, each layer $O_l$ of $O$ contains the three-tuple ${E\left(S, \psi, R\right)}$ where $E$ is a secure public key encryption function, $S$ is a secret value, $\psi$ is a time at which to transmit the next layer of the packet and $R$ is the remainder of $O$ consisting of recursive three-tuples. In this example, only the specific target $T$ will be able to decrypt $E$ and send a valid receipt back to the challenger, $C$.

We describe the approximate flow of \emph{Proof-of-Coverage} creation as follows:

\begin{enumerate}
  \item $T_1$ receives $O$ from $C$ via the peer-to-peer internet network and immediately broadcasts it via the wireless network
  \item $T$ hears $O$ and attempts to decrypt the value of $E$ by using its public key $pk:\ E_{pk}\left(S, \psi, R\right)$
  \item $T$ records both the time of arrival $\beta$ and the signal strength $\upsilon$ of $O$
  \item If successful, $T$ then creates signed receipt $K_S$, ${K_S = \left(S || \beta || \upsilon\right)}$ signed by the private key of $T$
  \item $T$ submits $K_S$ to $C$ via the peer-to-peer internet network, removes the outer most layer, and wirelessly broadcasts the remainder $O$
  \item These steps repeat for $T_1$..$T$..$T_L$, with $T_L$ being the last target in the graph
\end{enumerate}

$C$ expects to hear responses from $T_g$ within a time threshold $\lambda$, otherwise it considers the \emph{Proof-of-Coverage} to have concluded. Because $C$ is the only party with complete knowledge of $O$, upper bounds of the values for $\beta$ and $\upsilon$ are assigned by $C$ which are used to verify that each layer of $O$ was transmitted approximately where and when it was expected. The upper bound for $\beta$ ls limited by the speed of light $\tau$ between $T_n$ and $T_n-1$. Thus we know that, subject to some slight delays from reflection or multipath, the packet should not arrive at $T_g$ later than $\tau$ multiplied by the geographical distance $D$ plus some small episilon value, $\upsilon = \tau \times \Big(D + \epsilon\Big)$. For $\upsilon$, because of the inverse-square law, we can calculate the maximum RSSI possible for a packet transmitted, $\mu$, from $T_g-1$ to $T_g$ as $\mu = \frac{1}{D^2}$. Gateways that are closer than expected, or which are transmitting at a higher power to mask their location disparity, are unlikely to get $\mu$ correct, given that they do not know who the next layer of $O$ is addressed to.

Once $T_L$ has delivered receipt to $C$, or $\lambda$ has elapsed, the \emph{Proof-of-Coverage} is completed. The collection of signed receipts, $K_S$, constitute the \emph{Proof-of-Coverage} that $C$ will include when attempting to mine the next block in the blockchain [Section \ref{mining}].

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=\columnwidth]{o_propagation.eps}
          \caption{\emph{Proof-of-Coverage} flow}
          \label{fig:poc-propogation}
     \end{center}
\end{figure}

\textbf{Scoring} \label{scores} When miners join the Helium network, they are assigned a score, $\phi$, with a value of \textbf{0.500}. We consider any miner with a score greater than 0.500 to be an honest miner, $\eta$. This score depreciates linearly per block. As $\phi$ decreases the probability of the miner $M$ being the target for $C$ increases such that the network continually attempts to prove that the lowest scoring miners are acting honestly, and giving miners a reasonable chance to improve their score.

Given,\newline
\begin{tabular}{l l}
	$M$,       	  & miners                                         \\
	$h$,          & height of the blockchain                       \\
	$P(M)$,       & probability of $M$ being selected as target    \\
	$\phi_0$,     & score of $M$ initially                         \\
	$\phi_h$,     & score of $M$ at height h                       \\
	$\phi'_h$,    & depreciation value of $\phi_h$                 \\
	$\delta_h$,   & rate of decay of $\phi_h$                      \\
	$\epsilon_h$, & boost for $\phi_h$ on successful verification  \\
	$\alpha_h$,   & boost factor                                   \\
	$\eta_h$,     & honest miners                                  \\
	$\phi_{max}$, & local maximum score for $\eta_h$               \\
\end{tabular}

At every height h in the blockchain we have the following constraints:

The probability of a miner being selected as a target is bounded by:
\begin{equation*} \label{constraint1}
0 \leq P(M) < 1.0 \\
\end{equation*}

The score of a miner at height h always follows:
\begin{equation*} \label{constraint2}
\phi_h < 1.0, \hspace{0.5cm} \forall h > 0
\end{equation*}

As the blockchain increases in height, a miners score should tend towards 1.0. This implies that honest miners contributing to the \emph{Proof-of-Coverage} always gain score.
\begin{equation*} \label{goal}
\lim_{h \to \infty} \phi_h = 1.0
\end{equation*}

In order to satisfy the above defined constraints, we construct the following relationships:

The boost factor depends on the previous score and number of honest miners, it can be defined as:
\begin{equation*} \label{alpha}
\begin{split}
    \alpha_h & = g(\phi_{h-1}, \eta_{h-1}) \\
    & = \left\lvert 1 - \sqrt{1 - {(\phi_{h-1} - 1)}^2} \right\rvert \eta_{h-1} \\
\end{split}
\end{equation*}

Similarly, the boost allotted to each miner depends on the score and boost factor,
\begin{equation*} \label{epsilon}
\begin{split}
    \epsilon_h & = f(\phi_{h-1}, \alpha_h) \\
    & = \frac{\phi_{h-1}}{\sqrt{\phi_{h-1}} + \alpha_h^{-2}}\\
\end{split}
\end{equation*}

Finally, the rate of decrease of score is linearly proportional to the previous score. Doing so allows an equal opportunity for low scoring miners to gain score, while also making sure that miners can never reach the maximum possible score as the height of the blockchain increases.
\begin{equation*} \label{delta}
\delta_h \propto \phi_{h-1}
\end{equation*}

From the above defined relationships, we construct the following recurrence for the score of the miners:
\begin{equation*} \label{score}
	\phi_h = \begin{cases}
		\phi_{h-1} - \delta_h, \\
		\phi_{h-1} + \epsilon_{h-1} - \delta_h
	\end{cases}
\end{equation*}

Substituting the values for $\alpha_h$ and $\epsilon_h$, we get the following recurrence relationship as the score of miners:
\begin{equation*} \label{recurrence}
	\phi_h = \begin{cases}
		\phi_{h-1} - \delta_h,\\
		\phi_{h-1} + \frac{\phi_{h-1}}{\sqrt{\phi_{h-1}} + \left(\left\lvert1 - \sqrt{1 - (\phi_{h-1} - 1)^2}\right\rvert \eta_{h-1}\right)^{-2}} -\delta_h
	\end{cases}
\end{equation*}

\emph{Figure \ref{fig:score-graph}} shows a snapshot of a random subset of the network at any blockchain height \textit{h}. The miners represent random locations with an illustrated score, while the edges are calculated using Dijkstra's algorithm\cite{dijkstra}.

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=0.8\columnwidth]{chart.eps}
          \caption{\emph{Snapshot of a random subset of the initial network}}
          \label{fig:score-graph}
     \end{center}
\end{figure}

After 10,000 iterations the network appears as represented in \emph{Figure \ref{fig:score-graph10000}}.

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=0.8\columnwidth]{chart1000.eps}
          \caption{\emph{Snapshot of a random subset of the network after 10000 iterations}}
          \label{fig:score-graph10000}
     \end{center}
\end{figure}

The goal of this system is to ensure the scoring of miners considers that some miners may attempt to act dishonestly. However, because the calculated edge-weights (via Dijkstra's algorithm) and the target selection mechanism ensure that we only boost the score of a miner when it is being verified by other high scoring miners, we believe that the system will favor legitimate miners and deter dishonest ones.

\textbf{Verifying the Proof}. Once $T_L$ has delivered $K_S$, or $\lambda$ has elapsed, the \emph{Proof-of-Coverage} is considered complete. When $C$ attempts to mine the next block, all receipts $K_S$ from $T_1$...$T_L$ are included in the candidate block, $B_C$, published to the blockchain network [Section \ref{mining}]. As all the steps originally completed by $C$ are deterministic in nature with verifiable and recreatable randomness, it is simple for a verifying miners, $V$, to recreate the original steps and verify that the proof is legitimate.

Verifying miners who see $B_C$ are able to verify the \emph{Proof-of-Coverage} prior to considering the block by recreating the following steps:

\begin{enumerate}
        \item The verifying miner, $V$, reconstructs the hash ring of miners $\omega$
        \item Because $V$ is able to now see $B_C$, the random seed $\eta$ can be verified to have been created by the private key of $C$
        \item $V$ then selects $T$ from $\omega$, as seeding with $\eta$ will result in the same target selection
        \item The set of candidate $T_n$ are reconstructed from which $T_1$ and $T_L$ are determined
        \item Dijkstra's algorithm is used to reconstruct the graph $T_g$
        \item The $K_S$ receipts contained in $B_C$ are verified to have been signed by the private keys of $T_1$..$T$..$T_L$
\end{enumerate}

Assuming these steps are completed successfully, the \emph{Proof-of-Coverage} is verified and $B_C$ can be considered for inclusion in the blockchain [Section \ref{consensus}].

\subsection{Constructing \emph{Proof-of-Serialization}}

To achieve cryptographic time consensus among decentralized clients, we implement a simplified form of Googles Roughtime \cite{roughtime}. Roughtime is a protocol that aims to achieve roughtime synchronization in a secure way that does not depend on any particular time server, and in such a way that, if a time server does misbehave, clients end up with cryptographic proof of that behavior.

This section describes the construction of the \emph{Proof-of-Serialization} protocol.

\textbf{Creating the Proof}. We outline the approximate process to achieve cryptographically secure time as follows:

\begin{enumerate}
        \item To begin, a miner $M$ pseudo-randomly picks two miners $M_1$ and $M_2$, to prove contact serialization with
        \item It is assumed $M$ has a public key for $M_1$ and $M_2$, otherwise $M$ should obtain it from the blockchain
        \item $M$ generates a nonce, $R$, which is a SHA512 hash of the block which $M$ has partially constructed
        \item $M$ then generates a salted hash commitment $K$ called the \emph{proof-kernel} ${K = H\left(R || M_1 || M_2\right)}$
        \item $M$ sends $K$ to $M_1$. $M_1$ replies with $T$, a signed message including the current time $T_1$ and $K$
        \item $M$ knows that the reply from $M_1$ was not pre-generated because it includes the nonce $R$ that $M$ generated
\end{enumerate}

Because $M$ can not trust $M_1$ it will ask for another time from $M_2$:

\begin{enumerate}
        \item For the second request, a new nonce $R$ is generated using $T$ truncated to 512-bits, blinded by XOR'ing a randomly generated 512-bit number
        \item $M$ then generates a sub-proof-kernel, $L = H\left(R || T || K\right)$, and sends it to $M_2$
        \item $M_2$ replies with $U$, a signed message including the current time $T_2$ and $L$
        \item $U$ is now a proof artifact that shows that $M$ desired and then proved a serialization between $M_1$ and $M_2$
\end{enumerate}

With only two servers, $M$ can end up with proof that something is wrong, but no idea what the correct time is. But with half a dozen or more independent servers, $M$ will end up with chain of proof of any server's misbehaviour, signed by several others, and enough accurate replies to establish what the correct time is, $T_t$.

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=\columnwidth]{serialization.eps}
          \caption{\emph{Creating Proof-of-Serialization}}
          \label{fig:serialization}
     \end{center}
\end{figure}

\textbf{Verifying the Proof}. If we assume that the times from $M_1$ and $M_2$ are significantly different, and the time from $M_2$ is before $M_1$, then $M$ has proof of misbehaviour. The reply from $M_2$ implicitly shows that it was created later because of the way that $M$ constructed the nonce. If the time from $M_2$ is after, then $M$ can reverse the roles of $M_1$ and $M_2$ and repeat the process to obtain, assuming steady clocks, a misordered proof as in the other case.

To verify the correct time, it is necessary for $M$ to repeat the time synchronization process with enough miners to gain consensus on the correct time:

\begin{enumerate}
    \item A miner $M$ again pseudo-randomly selects $n$ miners $M_1$...$M_n$
    \item $M$ generates a salted hash commitment $K$ and delivers it to $M_1$, where ${K = H\left(R || M_1 || M_2\right)}$
    \item $M_1$ again responds with $T$, a signed message containing the current time $T_1$ and $K$
    \item $M$ generates a sub-proof-kernel, $L = H\left(R || T || K\right)$, and sends it to the next miner $M_n$
    \item The next miner replies with $U$, a signed message including the current time and $L$
    \item These steps repeat through $M_n$ until at least three time responses, $T_n$, are monotonic
    \item $T_n$ can then be confirmed to be $T_t$, the correct time
\end{enumerate}

\begin{figure}[H]
    \begin{center}
          \includegraphics[width=\columnwidth]{verify_serialization.eps}
          \caption{\emph{Verifying Proof-of-Serialization}}
          \label{fig:verify-serialization}
     \end{center}
\end{figure}

\textbf{Utilizing the Proven Time}. Once the correct time $T_t$ has been determined via \emph{Proof-of-Serialization}, it is used by $M$ and included during block construction as described in [Section \ref{blockchain}]. The randomness $\eta$ used to compute $O$ and thus obtain the \emph{Proof-of-Coverage} is tied to the previous block, which contains $T_t$. This allows us to prove, with relative certainty, that some piece of data $D$ was created between the time of the previous block $b_t$ and $T_t$. $D$ in this case is the \emph{Proof-of-Coverage}. Thus we know that $D$ must have been constructed between $b_t$ and $T_t$. This ensures that the \emph{Proof-of-Coverage} cannot be pre-computed and that that blocks in the blockchain must have a minimum spacing in time; the \emph{blocktime}. Blocks which do not have at least \emph{blocktime} distance in time from their parent block are considered invalid.

\section{Consensus Protocol}\label{consensus}

In this section, we illustrate the consensus protocol used in Helium. Instead of an extremely computationally expensive and power hungry \emph{Proof-of-Work}, Helium miners generate \emph{Proofs-of-Coverage} which allow them to partipciate in network consensus.

\subsection{Motivation}

Many current generation blockchains rely on a computationally difficult \emph{Proof-of-Work} to protect the network against sybil attacks. The fact that the \emph{Proof-of-Work} is computationally expensive to create, but cheap to verify means that in order to propose a new valid block to the network there is evidence that a significant amount of computation has been expended. Due to the fact that computation is limited by hardware cost, power cost, physical space and computational efficiency of modern technology, sybil attacks become impossible. However, this approach, while fundamental to the mainstream adoption of blockchain technology, has several downsides. Chief among the downsides is the power consumption; it is estimated that the Bitcoin network is consuming more power than many small countries. Bitcoin's PoW is so wasteful it is now on the list of the top uses of electricity in the world and whenever the value of Bitcoin goes up, so do the resources devoted to mining it.

Related to the power problem is the mining pool problem. Many blockchains have mining pools where users band together to, in parallel, mine a single block; listing the pool's address as the party to get paid. The pool then shares the block reward with the members of the pool. This ends up defeating many of the advantages of decentralization as both Bitcoin and Ethereum have come to be dominated by less than 10 mining pools each. These large pools effectively prevent independent parties from mining blocks on their own. This means that the consensus protocol for these blockchains is effectively controlled by a very small number of mining pools and risks becoming further centralized.

More recently there has been increased momentum around making blockchain consensus protocols less wasteful and more useful to the network. Filecoin \cite{filecoin} has a Proof-of-Spacetime and Ethereum \cite{ethereum} is moving towards a Proof-of-Stake approach. Helium has designed a unique consensus protocol around \emph{Proof-of-Coverage} to capture the useful but still difficult work of verifying the network of Helium miner as a replacement for \emph{Proof-of-Work}. In fact this proof is so valuable and fundamental to the network that we attempt to capture valid, but not winning, proofs in the main chain by the use of uncle blocks [Section \ref{blockchain}].

In addition, because each proof is unique to the miner producing it, pooling can not occur. This dramatically equalizes the chances that any particular miner can win a block and reduces the ability for any single entity to exert undue influence over the network or its consensus.

\subsection{Helium Consensus}

We propose a consensus protocol where the probability that a miner submits a winning block to the network is roughly proportional to the number of \emph{other} miners that were verified in the \emph{Proof-of-Coverage}. Because the \emph{Proof-of-Coverage} is generated in an unpredictable way, mining power is fairly equally distributed among the network. Miners offer wireless network coverage and verify others as proof to participate in the consensus.

Each miner has a score assigned to it by the blockchain, a value between 0 and 1. When miners join the network a default score $\phi$ is assigned. This score changes over time in response to \emph{Proof-of-Coverage} challenges. A miner that successfully answers a challenge is granted a boost to its score, as described in [Section \ref{scores}]. Miners with a higher score have a larger chance of submitting the winning block and miners with a lower score have a higher chance of being challenged. Thus the Helium consensus protocol rewards good behavior on the network and punishes bad behavior.

At each blocktime, a subset of miners $M_S$ are allowed to submit a candidate block. The chances of being chosen to submit a block are proportional to the miner's current score. $M_S$ are selected from a \emph{consistent hash ring} $\omega$ of potential miners. For miners with a low score proportionally more "blank" entries are inserted in the target candidate set. If a miner is assigned a blank target it cannot mine the block at this height. 

Once all the blocks for the interval $\lambda$ have been submitted, the network of miners each choose the block they think is the best, according to the scoring algorithm. The scoring algorithm favors blocks that are valuable to the network. The primary dimension affecting score is the \emph{Proof-of-Coverage} contained within the submitted block. A high scoring proof should either use successful, valid challenge responses to raise the score of as many miners as possible, or it should contain irrefutable proof of misbehavior. It should also come from a miner that has a good score itself. Secondarily, it should include references to high-quality uncle blocks that, while not winners at the time, contain highly valuable proofs themselves that would be wasteful to discard. Finally a good block should include as many valid transactions as possible, transactions are the life blood of a blockchain and it is vital miners are incentivized to include them.

The scoring algorithm for a submitted block can be represented as:

\[B_S = P_S + avg(U_S) + |T_n|  - S - L \]

Where $P_S$ represents the \emph{Proof-of-Coverage}, $U_S$ is the combined \emph{Proofs-of-Coverage} contained in all uncle blocks, $T_n$ are transactions, $S$ is a self-mining penalty, and $L$ is a late block penalty.

If a miner mines a block on top of a block that it also mined  a cumulative penalty, $S$, is applied relative to the number of blocks in a row mined by the same miner. Additionally, a penalty applied for the block being 'late', $L$, relative to the ideal blocktime spacing.

The block with the highest score, $B_S$, seen by miners on the network during the interval $\lambda$ is added to the head of their chain.

The criteria on which blocks are validated and scored must be agreed upon by all participants in the network. If there is disagreement around the consensus rules, the blockchain will fork. Because Helium miners have a reputation attached by way of their score, a simple 51\% attack is insufficient to derail the consensus algorithm. Additionally the inclusion of uncle blocks, according to the GHOST protocol \cite{ghost}, further increases the difficulty of a malicious consensus fork. Uncle blocks on the Helium blockchain are only eligible for inclusion if the uncle block and the block referencing it share a common ancestor within the last 7 generations. This means that after 7 generations the chain fork can no longer obtain a boost from including uncle blocks from the honest chain.

\section{Transactions}\label{transactions}

Transactions in the Helium blockchain provide functionality that enables address-to-address transfers of Helium tokens, similar to many existing blockchain networks, but also provide a set of primitives that enable core functionality that is critical to the operation of a \verb|DMN|. In this section we address the philosophy behind our transaction system, the primitives, and the way fees on the network work. We will first address Helium's need for microtransactions and propose a new solution.

\subsection{Microtransactions} \label{microtransactions}

In this section we discuss Helium's need for microtransactions, the limitations of existing solutions, and propose a solution based on staking and burning.

\subsubsection{Helium's Need for Microtransactions}

\paragraph{Devices Pay Per Packet}
The goal of Helium is to provide internet data transport fees (the fees paid by devices to miners) that are an order of magnitude less than anything currently available for this type of service. This transport fee would need to be metered per-packet in order to allow for maximum flexibility --- this way, a device could transact with any miner, even just to send or receive a single packet without having previously established a relationship with that miner.

\paragraph{All Transactions Occur On-Chain}
Helium is built on the philosophy that all transactions should occur \emph{on-chain}; that is, blocks should be sized and mined with a frequency such that every transaction which occurs on the network should be stored in the blockchain.  To accomplish this goal the cost of mining must be low, blocks must be large enough to encapsulate a large number of transactions, and frequent enough that transactions are processed quickly.

\paragraph{Allow Devices to Persist Data to the Blockchain}
Because the Helium blockchain services a specific use, the \verb|DMN|, blocks must additionally be able store fingerprints of data sent from devices along with the transaction which pays a miner for their transport service.  We believe that this holistic \emph{tamper-proof} data trail will enable entirely new use cases where the authenticity and veracity of sensor data is critical.

\subsubsection{Limitations of Existing Solutions}

Now that we have discussed the requirements of transactions within Helium, we outline the existing solutions for micropayments on a blockchain and address their shortcommings as they apply to our network.

\paragraph{Heavyweight Transactions}
This first option is suitable only for larger transactions as the service fee is smaller than the payment. This method does not work well for very small transactions as whoever pays the transaction fee ends up potentially paying more for the transaction fees than the value being exchanged. This is a similar problem to buying small-value items using credit cards today. The vendor pays a minimum fee on each credit card transaction, and under a certain charge they lose money on the transaction. These heavyweight transactions are clearly not suitable for use as a micro transaction system within Helium.

\paragraph{Zero-fee Transactions}
While highly desirable from a device perspective, a true zero-fee blockchain would be frought with spam transactions. It would be trivial to write a script to pollute the blockchain with transactions meant only to waste space on the blockchain and increase congestion on the network. Some ostensibly zero-fee blockchain implementations solve this issue in clever ways, such as offloading the work of processing and verifying transactions to the transactors themselves \cite{iota}. However, these implementations have their own issues, for example IOTA has not yet proved it is capable of operating this type of system without the need for a centralized coordinator.

\paragraph{State Channels}
State channels \cite{state-channels} allow two parties to exchange value, usually in small increments at a time, with very limited risk. If one party thinks the other is acting dishonestly, they can publish the final transaction in the state channel to the blockchain and close the channel. At most one payment is usually at risk. However, there are several downsides: the payer has to lock up significant funds for the lifetime of the state channel, meaning they may be unable to open state channels with other parties or pay other dues; transactions in the state channel do not appear on the main chain at all; and these implementations are relatively complex to execute well (note that neither Lightning \cite{lightning} nor Raiden \cite{raiden} have become widely used yet).

\paragraph{Payment in Arrear}
Payment in arrear, after the services have been rendered, is an extremely risky method in a decentralized pseudo-anonymous system. There is no mechanism to gain certainty around the intent or honesty of the entities transacting, nor do you know if the entities control the requisite funds when the debt comes due. This model only works when the parties involved trust each other, or have some other recourse to recover funds.

\subsubsection{A Proposed Solution Based on Staking \& Chits}

In order to satisfy our requirement of on-blockchain micro transactions with no fees, we propose a system that takes inspiration from staking and state channels.

In order for devices to issue zero fee payments to miners, they must first stake a \emph{deposit} of tokens using the \emph{create\_deposit} transaction [Section \ref{primitives}]. This transaction has a fee. Once the initial deposit has been created, the network user can proceed to issue \emph{chits} against their deposit until it is exhaused. Chits are a type of transaction; a promissory note that payment will be delivered in the future, and enough information to trust a favorable outcome. These chits are returned in response to a gateway offering a packet for delivery. Chits are linked to each other; the blockchain needs to have seen the previous chits before subsequent ones will be accepted. Each chit references the deposit, the sequence number (nonce), the amount to pay and any additional information about the packet.

Because the miner concerned wants to be paid for transport, it will add the chit to its mempool, along with any previous chits that it depends on. This means that several miners are all incentivized to include these chits in their current blockchain. The entity issuing \emph[chits] can use the final \emph[chit] in the transaction chain to incentivize a miner to include all the previous (or missing) chits in a block. If previous chits are not included in the chain, nobody gets paid.

At first glance this is similar to how state channels work, but with a couple of significant differences. State channels are a one to one construct, while chits can be one to many. Critically, this method keeps the record of all included transactions on-chain. The crucial benefit to this design is that all transaction fees for these payments can be eliminated. The first staking transaction can be sent along with the first chit, so the gateway is incentivized to add it to their block. If the first miner doesn't include it, the second \emph{chit} can be accompanied with the staking transaction and the first chit when communicating with the next miner. Eventually the advantage of including the transactions outweighs the disadvantages.

It is important to note that nobody gets paid until everybody gets paid. Chits should not be issued after the \emph{ExpiryHeight}. If the deposit is not distributed $n$ blocks after the ExpiryHeight, the deposit is disbursed as much as possible and any remaining balance is destroyed. This provides an incentive for everyone involved to settle the balance.

\subsubsection{Example Deposit Lifecycle}

In this section, we will walk through an example lifecycle of a router staking a deposit, miners performing work on behalf of the router, and being compensated by the router through chits agaist the deposit.

\begin{enumerate}

\item A router $R$ creates a deposit $S$ of 500 tokens, expiring at block height $current\_height$ + $\lambda$, by publishing a \verb|create_deposit| transaction and paying a nominal transaction fee
\item A miner $M_1$ hears a packet $P_1$ broadcast by device $D$
\item $M_1$ uses the address of $D$, attached to $P_1$, to identify $R$ as the owner of $D$
\item $M_1$ sends the signature $K(P_1)$ of $P_1$ and an offer of 1 token for transport to $R$
\item $R$ receives $K(P_1)$ and the payment offer and determines if it accepts the packet for the offered price
\item Assuming $R$ accepts the packet at the offered price, it constructs a \textbf{chit} transaction $C_1$ with nonce 1, with a value of 1 token, payable to $M_1$, against $S$ and sends it to $M_1$
\item Having received $C_1$, $M_1$ verifies the correctness of $C_1$ by inspecting $S$ on the blockchain and sends $P$ to $R$
\item $M_1$ adds $C_1$ to its mempool and gossips it to the peer-to-peer internet network
\item Meanwhile, $D$ has physically moved and broadcasts its next packet $P_2$. A different miner $M_2$ now hears $P_2$
\item Just as before, $M_2$ sends $K(P_2)$ to $R$ along with an offer of 0.9 tokens for transport
\item $R$ responds with a chit $C_2$, but since $C_1$ has not been included in a block yet, and chits must be included in nonce order, $R$ also sends $C_1$
\item $M_2$ adds $C_1$ and $C_2$ to its mempool and gossips both chit transactions to the peer-to-peer network
\item $M_1$, being invested in deposit $S$, hears about the new chit $C_2$ over the peer-to-peer network and adds it to its mempool
\item $R$ continues issuing chits $C_n$ against $S$ until either:
  \begin{enumerate}
  \item The value of $S$ is depleted, at which point $R$ can create a new deposit
  \item $S$ expires at the previously specified block height and the remaining balance is burned
  \end{enumerate}
\item Once $S$ is closed either through depletion or expiration, all gateways owning chits against $S$ receive their payment
\end{enumerate}

\subsubsection{Problems \& Solutions}

In this section we address potential problems that could arise with the deposit \& chit approach and present solutions to these problems.

\paragraph{Degenerate Miner} A miner, after being issued a chit for the service it has agreed to perform, could neglect to follow through and perform the service. If a miner fails to send the agreed packet to the router after the router issues a chit, the router can re-request it (for some period of time). The threat of losing future business from a router and the relatively low overhead of completing the transfer of the packet acts to disincentivize miners from acting in bad faith. This is consistent with state channel implementations where the task is subdivided such that the scope of potential loss is below a meaningful threshold.

\paragraph{Chit Bomb} A malicious actor could stake a deposit and then proceed to issue a near limitless amount of miniscule chits against that deposit without incurring transaction fees. This could flood mempools and pollute the blockchain with spam transactions. Assuming we trust our network of miners [Section \ref{scores}], this could never happen. Miners are the only entity on the network capable of creating new blocks for the blockchain, and chits can only be issued to miners in payment for their services. Because we assume all miners to be selfish, we anticipate they will only include transactions that benefit themselves. These are either transactions with fees attached, or chits that they have a direct investment in, either because they will get paid, or because the transaction is attached to a stake in which they have chits. Therefore, we expect miners to ignore any spam chits that were not issued in exchange for a service provided.

\paragraph{Final Transaction}
In theory, it is possible for the chit issuer to spend all the staked tokens and not have anything left to incentivize a miner to include the final transaction. All the miners involved in the chain of chits have an incentive to get the transaction included in a block, and because there is a fair chance of any individual miner winning a block, this should eventually clear.

\subsection{Light Clients \& Full Nodes} \label{full-nodes}

Until now, we have discussed how to deal with microtransactions in a cost-effective way, however we have not yet addressed how to deal with the inevitable continuously increasing size of the blockchain. One requirement for Helium is that all transactions occur on-chain. This means that the size of the full blockchain will eventually grow quite large. This is compounded by the fact that all miners on the network are gateway devices, relatively limited in computation power and storage space.

We solve this constraint by allowing mining nodes to operate as \emph{light clients} on the blockchain, pruning old blocks and transactions as needed and keeping only the latest ledger values. They will communicate over the peer-to-peer network with \emph{full nodes} which maintain a complete history of the blockchain to verify transactions.

This raises a question: who is responsible for operating full nodes, and what is their incentive to do so? Routers are software-only applications with access to scalable, cloud-based storage and will be required to operate full nodes in order to fulfill their purpose. Helium Systems Inc will operate a set of hosted routers that will make it easy for developers to launch products without needing to deploy their own router. However, many enterprise developers, who are required to maintain a higher standard of privacy, will want to host their own router. Together, these routers will form a network of full nodes capable of supporting resource constrained gateways and wallets operating light clients.

\subsection{Fees} \label{fees}

Transaction fees are an essential part of most blockchain implementations. They incentivize miners to include a transaction in their draft block and ensure that spam transactions do not pollute the blockchain and network. We've discussed how the \emph{chit} transaction [Section \ref{chit}] is able to eliminate fees in the prior section on Microtransactions [Section \ref{microtransactions}]. However, all other transactions on the \verb|DMN| require transaction fees.

To determine the appropriate fee for a new transaction, the transactor will take the median of the past $\delta$ packet transport fees, within some margin of error. Until $\delta$ packet transports have been completed, the fee will be fixed at a constant value $\alpha$. By anchoring the transaction fee to the current fees being charged for transport on the network, we root them in reality. Helium's primary purpose is to facilitate a network of wireless ineternet coverage. In order to accomplish this in the long term, all of the economics of the system must align to make it practical for the primary users to transact on the network. If one set of fees were to outstrip the other, the network would quickly lose its utility for the key user segment.

To enable miners and other light clients to determine an appropriate fee, full nodes [Section \ref{full-nodes}] will expose a fee suggestion API. This way resource constrained entities that do not maintain a complete copy of the blockchain will not need to compute the fee from the most recent transactions. When submitting a block, peer miners will verify the correctness of the block and ensure that no fee has deviated beyond the acceptable threshold of $\delta$.

\subsection{Staking} \label{staking}

The \emph{assert\_location} transaction, mentioned below [Section \ref{primitives}], has a special type of fee calculation; a \emph{dynamic} fee. Because the Helium network reaches maximum \emph{usefulness} at a specific density of gateways, we want the fees to incentivize the network density to be as close to that ideal as possible. To that end, the transaction fee for asserting a location can be thought of as the y coordinate on a curve with the formula \[\mathit{y = \left(x - D\right)^4 + F}\] where $D$ is the ideal gateway density and $F$ is the unit fee for a location transaction. A sample graph of this function where $D$ = 3 and $F$ = 1 follows:

\pgfplotsset{width=12cm,compat=1.9}
\begin{tikzpicture}[scale=\columnwidth/12cm]
    \begin{axis}[xlabel = Density, ylabel = Fee]
        \addplot[color=gray, domain=0:6]{(x - 3)^4 + 1};
    \end{axis}
\end{tikzpicture}

As can be seen, gateways near the ideal network density are cheap to add, but establishing a new network or overpopulating a network gets expensive very quickly. This serves to dis-incentivize gateway deployments that are not beneficial to the network. In particular, \emph{Alternate Reality Attacks} and warehouses full of miners become prohibitively expensive.

Blocks submitted to the network by miners who have not asserted their location, and therefore not paid the staking fee, will be considered invalid and not considered by miners for inclusion in the chain.

Miners who move physical location will need to assert a new location, and pay the new staking fee.

\subsection{Primitives in Helium} \label{primitives}
Having discussed the philosophy of our transaction system and presented our approach to facilitating zero-fee mictrotransactions on the Helium network, we now delineate the transaction primitives and their properties.

\begin{description}
  \item [add\_gateway] Registers a new gateway on the network, adding it to an existing account which will be responsible for supplying its stake (required for mining) and will receive mining rewards [Section \ref{mining}] and fees earned by the gateway

\begin{table}[H]
  \centering
  \begin{tabularx}{\columnwidth}{l X}
    \toprule
    Property & Description \\ \midrule
    gateway\_address & the address of the gateway being added to the network \\
    public\_key & the public key of the gateway being added to the network \\
    owner\_address & the address of the owner account \\
    signatures & mutual signatures of the owner and gateway
  \end{tabularx}
\end{table}

\item [assert\_location] Asserts a gateway's location in the form of geographic coordinates, requiring a dynamic stake

\begin{table}[H]
  \centering
  \begin{tabularx}{\columnwidth}{l X}
      \toprule
      Property & Description \\ \midrule
      gateway\_address & the address asserting its location \\
      nonce & a monotoically increasing integer \\
      latitude & the latitude of the gateway \\
      longitude & the longitude of the gateway \\
      altitude & the altitude of the gateway \\
      signature & the signature of the gateway
  \end{tabularx}
\end{table}

\item [payment] \label{payment} Moves tokens from one account, the \emph{payer}, to another account, the \emph{payee}. N.B. this payment transaction requires a fee, while \emph{chit} [Section \ref{chit}] does not.

\begin{table}[H]
  \centering
  \begin{tabularx}{\columnwidth}{l X}
      \toprule
      Property & Description \\ \midrule
      payer\_address & the address of the sender \\
      payee\_address & the address of the recipient \\
      nonce & a monotoically increasing integer \\
      value & an integer-based representation of the tokens to send \\
      signature & the signature of the sender
  \end{tabularx}
\end{table}

\item [create\_deposit] Creates a staked deposit which can later be fractionally issued and redeemed in the form of \emph{chits} [Section \ref{chit}] without incurring transaction fees. Any unused portion of the deposit will be burned after some time.

\begin{table}[H]
  \centering
  \begin{tabularx}{\columnwidth}{l X}
      \toprule
      Property & Description \\ \midrule
      address & the address of the account creating the deposit \\
      value & an integer-based representation of the deposit amount \\
      public\_key & an ephemeral public key used for signing chits for this deposit \\
      expiry\_height & the block height at which this stake expires \\
      signature & the signature of the depositor
  \end{tabularx}
\end{table}

\item [chit] \label{chit} Issues a chit against a previously staked deposit in payment for transport or other services. N.B. this payment transaction does not require a fee, while \emph{payment} [Section \ref{payment}] does.

\begin{table}[H]
  \centering
  \begin{tabularx}{\columnwidth}{l X}
      \toprule
      Property & Description \\ \midrule
      public\_key & the public key used to create the deposit \\
      value & an integer-based representaion of the value of the chit \\
      nonce & a monotoically increasing integer \\
      packet\_reference & a hash of the packet being paid for \\
      payee\_address & the address of the recipient \\
      signature & the signature of the depositor
  \end{tabularx}
\end{table}

\end{description}

\section{Future Work}

This paper presents a well thought-out design for building the Helium network. However, we consider this to be just the beginning of the engineering, research and design of decentralized wireless networks. We believe that this tight integration of real-world hardware with a blockchain and a native token is a novel and valuable innovation that can be applied to other kinds of networks and wireless physical layers. We believe that the future of blockchains is not about who has the most hashing power or access to the cheapest electricity, but about blockchains where the mining proof is tied to providing a valuable, verifiable service. 

There are several intiatives that we either have or intend to undertake, including:

\begin{itemize}
    \item Investigate the applicability of applying these ideas to other physical layers such as WiFi, Bluetooth and Cellular
    \item Explore the potential for the delivery of 5G 60GHz+ mmWave connectivity through a similar design
    \item Research and implement more \emph{Proofs-of-Coverage} to keep the network secure as it grows
    \item Game theoretical analysis of the incentive system
    \item Formally prove the scoring algorithm used in the \emph{Proof-of-Coverage}
    \item Create and release the \emph{WHIP} wireless specification
    \item Manufacture gateways and device modules for availability at network launch
    \item Investigate the depoyment of smart contracts beyond the basic \verb|DMN| primitives
    \item Continued work and evolution of Forward Error Correction technqiues
\end{itemize}

\acks

This document is the result of collaborative work by members of the Helium team, and would not have been possible without the help, feedback, and review of the board of directors, advisors, investors and collaborators of Helium. We extend our most heartfelt thanks to all involved.

We would also like to extend our thanks to Jeremy Rubin of the MIT Digital Currency Initiative. Your earliest feedback and direction was critical to some of the design decisions and evolution of this project. We also thank the Blockchain at Berkeley team for their help and detailed review of this work.

We would also like to acknowledge many of the prior works and inventions that have allowed us to create this project, most notably Bitcoin~\cite{bitcoin} and Ethereum~\cite{ethereum}. We would also like to extend our appreciation to Protocol Labs~\cite{protocol} who demonstrated a path for regulatory-compliant sales of protocols under development and pioneered work around the SAFT, which we have followed.
\newpage

\begin{thebibliography}{10}
\softraggedright

\bibitem{napster} 
    Shawn Fanning. 
    \emph{Napster - independent peer-to-peer file sharing}, 1999

\bibitem{mckinsey}
    James Manyika, Michael Chui, Peter Bisson, Jonathan Woetzel, Richard Dobbs, Jacques Bughin, Dan Aharon. 
    \emph{Unlocking the potential of the Internet of Things}, 2015

\bibitem{ghost}
    Yonatan Sompolinsky. 
    \emph{Secure High-Rate Transaction Processing in Bitcoin}

\bibitem{nist}
    Mehmet Adalier. 
    \emph{Efficient and Secure Elliptic Curve Cryptography Implementation of Curve P-256}

\bibitem{ethereum}
    Vitalik Buterin. 
    \emph{Ethereum}, 2014

\bibitem{lora}
    LoRa Alliance. 
    \emph{LoRa Alliance - Wide Area Networks for IoT}, 2013

\bibitem{rpma}
    Ingenu. 
    \emph{RPMA Technology}

\bibitem{ieee802_15_4}
    IEEE. 
    \emph{IEEE Standard for Low-Rate Wireless Networks}, 2015

\bibitem{bitcoin}
    Satoshi Nakamoto. 
    \emph{Bitcoin: A peer-to-peer electronic cash system}, 2008

\bibitem{dijkstra}
    Dijkstra, E. W. 
    \emph{A note on two problems in connection with graphs}, 1959

\bibitem{hashing}
    David Karger, Eric Lehman, Tom Leighton, Matthew Levine, Daniel Lewin, Rina Panigrahy. 
    \emph{Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web}, 1997

\bibitem{roughtime}
    Adam Langley, Google. 
    \emph{Roughtime - a project that aims to provide secure time synchronisation}

\bibitem{gtp}
    Mehmud Abliz, Taieb Znati. 
    \emph{A Guided Tour Puzzle for Denial of Service Prevention}, 2009

\bibitem{tdoa}
    Regina Kaune, Julian Horst, Wolfgang Koch. 
    \emph{Accuracy Analysis for TDOA Localization in Sensor Networks}, 2011

\bibitem{iota}
    David Snsteb, Sergey Ivancheglo, Dominik Schiener, and Serguei Popov. 
    \emph{IOTA - Next Generation Blockchain}, 2015

\bibitem{lightning}
    Joseph Poon, Thaddeus Dryja. 
    \emph{Lightning Network - Scalable, Instant Bitcoin/Blockchain Transactions}, 2017

\bibitem{raiden}
    brainbot. 
    \emph{The Raiden Network - Fast, cheap, scalable token transfers for Ethereum}, 2017

\bibitem{state-channels}
    Jeff Coleman. 
    \emph{State Channels}, 2015

\bibitem{filecoin}
    Protocol Labs. 
    \emph{Filecoin}, 2017

\bibitem{protocol}
    Juan Benet. 
    \emph{Protocol Labs}, 2014

\end{thebibliography}

\end{document}
